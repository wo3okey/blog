{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"shard \nshard는 mysql과 같은 RDB를 기준으로 partition과 같은 의미로, 데이터를 저장할 때 나누어진 조각 단위라고 생각하면 된다. 즉 shard의 데이터는 복사본이 아닌 저장한 데이터 그 자체이다. elasticsearch에서는 충분히 크기가 큰 데이터를 가진 index의 데이터를 특정한 파티션 단위로 나누며, 이를 shard라고 …","fields":{"slug":"/elasticsearch-shard-replica/"},"frontmatter":{"date":"January 29, 2023","title":"그래서 elasticsearch shard, replica 값은 어떻게 설정할까?","tags":["elasticsearch","shard","replica"],"series":"elasticsearch"},"rawMarkdownBody":"\n\n## shard\n![](elasticsearch-shard-replica-02.png )\nshard는 mysql과 같은 RDB를 기준으로 partition과 같은 의미로, 데이터를 저장할 때 나누어진 조각 단위라고 생각하면 된다. 즉 shard의 데이터는 복사본이 아닌 저장한 데이터 그 자체이다. elasticsearch에서는 충분히 크기가 큰 데이터를 가진 index의 데이터를 특정한 파티션 단위로 나누며, 이를 shard라고 부른다. 각 document 문서는 해당 문서의 hash 값을 통해 계산된 shard로 라우팅 된다. 그리고 일반적으로 `shard`라고 하는 것이 primary shard를 뜻한다. 복사되지 않은 CRUD의 주체가 되는 실제 원본 데이터를 뜻한다.\n\n### shard 값 설정\nshard 하나의 크기는 일반적으로 최대 50GB이하, 통상적으로 20~40GB 정도 선을 유지하기를 권고하고 있다. 이는 elasticsearch 공식 문서에서 가이드한 값이기도 하며 통상적으로 많은 개발자들이 검증을 한 값이므로 신뢰도가 높다. 하지만 무엇이든 본인의 상황에 맞게 대입하면 된다. 적은량의 데이터를 핸들링할 경우 최소 2개 이상의 node에 shard를 1대만 두고 replica만 세팅해도 상관은 없는 것이다. 다만 primary shard를 결정하는 shard의 값만 많이 설정하고, replica를 적절히 설정하지 않으면 장애발생에 대한 fail-over에 대응이 불가할 수 있으며, 각 node별 검색성능에 좋지않을 수 있다. 그렇다면 replica shard의 갯수를 결정하는 replica 값은 어떻게 설정하고, 어떠한 역할을 하는 것일까?\n\n## replica\n![](elasticsearch-shard-replica-03.png )\nreplica를 한 마디로 정의하면 `shard의 복제된 갯수` 로 정의 할 수 있다. 만약 primary shard가 3일때, replica를 2로 설정하면 replica shard의 갯수는 6개로, 총 9개의 shard가 존재한다는 뜻이다. 이때 replica shard는 절대 primary shard와 동일한 데이터를 갖도록 node 내에서 존재 할 수 없다. 그래서 위 그림 처럼 초록색의 primary shard와 다른 번호로 주황색의 replica shard들이 각 node에 배치된 모습을 볼 수 있다.\n\nreplica shard는 각 node에 분산된 primary shard의 복제 역할을 함으로써 두가지 장점의 기능을 갖게 된다. 먼저 특정 node로부터 온 요청사항을 다른 node에 찾는 번거로움 없이 primary shard와 함께 온전히 지원할 수 있음으로써 검색성능 향상(search performance)을 기대할 수 있다. 그리고 node 자체에 장애가 발생하더라도 서비스에는 문제 없도록 장애복구(fail-over) 역할을 할 수 있다. 위 그림에도 node 1~3중 하나가 문제 생기더라도 primary, replica shard 관계없이 각각의 node의 shard가 전체 데이터인 0~2번까지 모두 서비스 될 수 있기 때문이다. 만약 위 상황에서 3개의 node중 2개가 모두 장애가 발생한다면 자연스럽게 남은 하나의 node에 있는 replica shard들이 모든 primary shard의 역할을 하는것이다. \n\n### replica 값 설정\n위 내용을 유추해보면 node는 결국 최소 2개는 있어야 하나의 node가 장애가 났을때 최소한의 fail-over이 가능하며, 이때 replica는 최소 1이상 설정해야 primary shard의 역할을 대신 할 수 있다.\n즉 replica 값은 아래와 같이 정리할 수 있다. 물론 디테일한 설정은 서비스 운용 상황에 따라 모두 다르다.\n> replica의 최소 값은 1, 최대 값은 전체 node 갯수 - 1\n\nreplica 수가 많다고 무조건 좋은건 아니다. replica가 많아질 수록 색인 성능은 떨어지고, 읽기 성능은 좋아진다. 복제된 공간만큼 데이터 정보를 채워 넣어야하니 색인(indexing)성능은 자연스럽게 떨어지며, 특정 node에 온 요청을 해당 node의 shard에서 모두 처리 가능하게 설정함으로써 읽기 검색성능 향상을 기대할 수 있다.\n\n## 실제 설정 예시\n그렇다면 실제 적용한 예시(index, ip, node는 임의로 변경) 상황을 보자. shard 수를 몇개씩 설정할 정도로 꼭 수십기가의 데이터를 저장한 예시가 아닌, 정말 작은 데이터에서도 elasticsearch를 활용하기 위해 색인을 한 경우다.\n\n```\nGET _cat/shards/index-v2?pretty&v\n```\n간단한 shard 상태를 조회하는 qeury를 통해 현재 샤드의 상태 및 정보들을 알 수 있다. \n\n```\nindex    shard prirep state   docs  store  ip       node\nindex-v2 0     p      STARTED 24008   25mb x.x.x.x  node1\nindex-v2 0     r      STARTED 24008 25.1mb x.x.x.x  node3\nindex-v2 0     r      STARTED 24008   25mb x.x.x.x  node10\nindex-v2 0     r      STARTED 24008   25mb x.x.x.x  node6\nindex-v2 0     r      STARTED 24008   25mb x.x.x.x  node4\nindex-v2 0     r      STARTED 24008 24.9mb x.x.x.x  node9\nindex-v2 0     r      STARTED 24008 25.1mb x.x.x.x  node7\nindex-v2 0     r      STARTED 24008 25.1mb x.x.x.x  node5\nindex-v2 0     r      STARTED 24008 25.2mb x.x.x.x  node8\nindex-v2 0     r      STARTED 24008 25.1mb x.x.x.x  node2\n```\n\n결과로 나온 `index-v2` index의 shard에 대한 현재 스펙은 아래와 같다. \n* node: 10개\n* shard(primary): 1\n* replica: 9\n* doument: 24,008개\n* store(avg): 25mb\n\n공식 문서나 블로그에 예시로 많이 설명되는 정보와 다르게 매우 작은 2만5천개의 문서인 25메가바이트 정보로도 elasticsearch의 장점을 활용하기 위해 index를 만들어 활용하고 있다. shard의 갯수가 1인것은 당연한 이유이다. 용량이 매우 적기 때문이다. 그렇다면 replica 수는 왜 9개나 되는것일까? 사실 이보다 적어도 상관 없다. 다만 현재 운용중인 node의 갯수가 10개이며, primary shard를 제외하고 남는 node에 모두 검색성능 향상을 위해 replica를 두고 싶은 이유이다. \n\n![](elasticsearch-shard-replica-04.png )\n\n그림으로 보면 이런 느낌이 아닐까 싶다. 되게 어색해 보일 수 있지만 현재 운용중인 10개의 node를 최대한 활용하여 검색성능은 최대로 끌어올릴 수 있다. 또한 primary shard가 자리잡은 node1이 장애가 발생하더라도 나머지 9개의 node들이 replica shard에 의해 primary shard 역할을 할 수 있는 형태이다. 그렇다면 위에서 언급한대로 replica의 수가 너무 많으면 색인 속도가 늦어질 수 있지 않는가? 그럴순 있다. 하지만 이 또한 서비스 운용에 따라 선택하면 된다. 해당 서비스의 index 색인은 빈번하게 일어나지 않는 도메인이기 때문이다. 그저 색인 성능에 상관없이 검색성능과 운영 관점에 초점을 맞추어 replica 갯수를 설정했기 때문이다.\n\n\n\n## 그래서?\nshard와 replica는 운영 관점에서 매우 중요한 역할을 한다. 어떻게 값을 설정하느냐에 따라 검색속도나 운영에서 미치는 영향이 매우크다. 그래서 elasticsearch의 shard와 replica 값을 설정함에 있어서 정리하자면 아래와 같다.\n>어느정도 가이드된 범위 내에서 서비스 도메인 별로 검색성능과 fail-over 관점을 잘 고려하여 각자 운영에 맞는 입맛대로 설정하면 된다.\n\n##\n***\n###\n* <https://aws.amazon.com/ko/blogs/database/get-started-with-amazon-elasticsearch-service-how-many-shards-do-i-need/>\n* <https://brunch.co.kr/@alden/39>\n* <https://fdv.gitbooks.io/elasticsearch-cluster-design-the-definitive-guide/content/a-few-things-you-need-to-know-about-lucene.html>\n* <https://esbook.kimjmin.net/03-cluster/3.2-index-and-shards>\n\n\n"},{"excerpt":"Data class java의 lombok도 편하지만 kotlin data class는 기본적인 메소드들을 만들기 진짜 세상 편하다. 하지만 상속을 할때에는 꼭 유의해야하는 사항이 있다. 차근차근 알아보자. hash code 먼저 data class를 선언 했을때 컴파일러가 만들어주는 hash code 메소드를 살펴보자. 간단한  객체를 만들었다. 그리고…","fields":{"slug":"/kotlin-data-class/"},"frontmatter":{"date":"January 28, 2023","title":"그래서 kotlin data class 상속은?","tags":["kotlin"],"series":"kotlin"},"rawMarkdownBody":"\n## Data class\njava의 lombok도 편하지만 kotlin data class는 기본적인 메소드들을 만들기 진짜 세상 편하다. 하지만 상속을 할때에는 꼭 유의해야하는 사항이 있다. 차근차근 알아보자.\n\n### hash code\n먼저 data class를 선언 했을때 컴파일러가 만들어주는 hash code 메소드를 살펴보자. 간단한 `Person` 객체를 만들었다. 그리고 java 코드로 decompile하여 `hashCode()`만 가져왔다.\n\n`kotlin`\n```kotlin\ndata class DataClassPerson(\n    val name: String,\n    val age: Int,\n    val phone: String\n)\n```\n\n`java`\n```java\npublic int hashCode() {\n    String var10000 = this.name;\n    int var1 = ((var10000 != null ? var10000.hashCode() : 0) * 31 + Integer.hashCode(this.age)) * 31;\n    String var10001 = this.phone;\n    return var1 + (var10001 != null ? var10001.hashCode() : 0);\n}\n```\n\n`hashCode()`를 살펴보면 단순히 정의된 변수의 값으로만 hash값을 만들고 있다. 즉 선언된 객체의 변수값들이 같으면 같은 hashcode를 갖는다는 것이다. 바로 한번 확인해보자.\n\n`kotlin`\n```kotlin\nfun main() {\n    val a = DataClassPerson(\"A\", 30, \"010-1234-5678\")\n    val a1 = DataClassPerson(\"A\", 30, \"010-1234-5678\")\n    val b = DataClassPerson(\"B\", 30, \"010-1234-5678\")\n\n    println(a.hashCode() == a1.hashCode())\n    println(a.hashCode() == b.hashCode())\n}\n```\n\n```\ntrue\nfalse\n```\n\n예상대로 위 경우 a, a1에 대해 객체의 값이 모두 같으므로 hash code 비교결과가 `true`로 나온다. 또한 a, b에 대해 name값이 다르므로 hash code 비교 결과가 `false`이다. 단순히 변수값만 비교한 값이므로 당연한 결과이다. 그렇다면 data class가 아닌 일반 class는 어떨까?\n\n`kotlin`\n```kotlin\nclass NormalClassPerson(\n    val name: String,\n    val age: Int,\n    val phone: String\n)\n\nfun main() {\n    val a = NormalClassPerson(\"A\", 30, \"010-1234-5678\")\n    val a1 = NormalClassPerson(\"A\", 30, \"010-1234-5678\")\n\n    println(a.hashCode() == a1.hashCode())\n}\n```\n```\nfalse\n```\na, a1은 hashcode가 같지 않다는 `false` 결과를 바로 확인 할 수 있다.\n\n## Data class 상속\ndata class의 부모객체(SuperClass)를 하나 설정해보자. \n\n`kotlin`\n```kotlin\ndata class SuperClass(\n    val superData: String = \"\"\n)\n\ndata class DataClassPerson(\n    val name: String,\n    val age: Int,\n    val phone: String,\n): SuperClass()\n```\n\n일단 위 코드는 컴파일 되지 않는다. data class끼리 상속하거나 받을순 없다. 이유는 간단하다. \n* decompile java 코드를 보면 data class는 기본적으로 `final` 클래스로 정의 되어있기에 상속을 막아뒀다.\n* 만약 억지로 상속한다 해도 data class에서 만들어주는 기본 메소드들을 부모와 자식것 중 어떤걸로 선택해야할지 정의할 수 없을 것이다. 그렇다고 강제로 어느것으로 정의하기에도 좀...\n\n그래서 애초에 막아뒀다고 생각한다. 그렇다면 부모 객체 및 변수에 상속 가능한 `open` 키워드를 붙이고, `hashCode()` 까지 재정의하여 data class에 상속을 해보자.\n\n`kotlin`\n```kotlin\nopen class SuperClass(\n    open var superData: String = \"\"\n) {\n    override fun hashCode(): Int {\n        return 1\n    }\n}\n\ndata class DataClassPerson(\n    val name: String,\n    val age: Int,\n    val phone: String,\n): SuperClass()\n\nfun main() {\n    val a = DataClassPerson(\"A\", 30, \"010-1234-5678\")\n    val a1 = DataClassPerson(\"A\", 30, \"010-1234-5678\").apply { superData = \"super\" }\n\n    println(a.hashCode() == a1.hashCode())\n}\n```\n```\ntrue\n```\na1에 상속받은 클래스의 `superData` 값을 변경했지만 a, a1의 hashCode는 같다. 이유는 간단하다. kotlin에서는 상속을 받을 때 이미 자식 객체에서 기본 메소드가 정의 되어있다면 이는 재정의 하지 않기 때문이다. 그래서 a, a1은 `DataClassPerson`에 정의된 변수만 가지고 hashcode 값을 정의한다. 그렇다면 상속받은 두 객체 a, a1의 hashcode는 어떻게 구분할 수 있는가? 답은 간단하다. 상속은 상속답게 `override`로 부모 변수를 받아서 재정의 하면 된다.\n\n`kotlin`\n```kotlin\ndata class DataClassPerson(\n    val name: String,\n    val age: Int,\n    val phone: String,\n    override var superData: String = \"\"\n): SuperClass()\n\nfun main() {\n    val a = DataClassPerson(\"A\", 30, \"010-1234-5678\")\n    val a1 = DataClassPerson(\"A\", 30, \"010-1234-5678\").apply { superData = \"super\" }\n\n    println(a.hashCode() == a1.hashCode())\n}\n```\n```\nfalse\n```\n\n## 그래서?\njava, kotlin 할 것 없이 상속은 간단하고 자주 사용되는 기본적인 문법이지만, 항상 주의를 기울여야한다. 그래서 kotlin 상속시 다음 유의 사항들은 살펴보면 좋을것 같다.\n> 상속한 객체의 변수는 가능한 override 해서 사용할것.<br>\n> 반드시 부모객체의 정보를 받아야는게 아니라면, 상속이 아닌 interface를 활용하여 재정의 할것."},{"excerpt":"inline kotlin 함수에 붙는  키워드는 말 그대로 호출되는 특정 코드 line 사이에 특정 inline 키워드가 붙은 함수의 코드를 넣을(in) 수 있도록 지원하는 키워드이다.\n 키워드는 객체(클래스)와 함수 레벨에서 사용할 수 있다. 예시는 객체 레벨이 아닌 함수 레벨에서 설명한다. inline 함수 간단하게 아래 코드로 살펴보자. 아주 inl…","fields":{"slug":"/kotlin-inline/"},"frontmatter":{"date":"January 23, 2023","title":"그래서 kotlin inline은 무엇인가?","tags":["kotlin","java","inline"],"series":"kotlin"},"rawMarkdownBody":"\n\n## inline\nkotlin 함수에 붙는 `inline` 키워드는 말 그대로 호출되는 특정 코드 line 사이에 특정 inline 키워드가 붙은 함수의 코드를 넣을(in) 수 있도록 지원하는 키워드이다.\n`inline` 키워드는 객체(클래스)와 함수 레벨에서 사용할 수 있다. 예시는 객체 레벨이 아닌 함수 레벨에서 설명한다.\n\n### inline 함수\n\n간단하게 아래 코드로 살펴보자. 아주 inline이 붙은 코드를 호출한 위치에 넣어주는 단순 역할 그 잡채이다.\n\n\n`Kotlin`\n```kotlin\nfun main(args: Array<String>) {\n    println(\"print1\")\n    print2and3()\n    println(\"print4\")\n    print5 { \"print5\" }\n}\n\nfun print2and3() {\n    println(\"print2\")\n    println(\"print3\")\n}\n\nfun print5(lambda: () -> String) {\n    println(lambda.invoke())\n}\n```\n\n`Java`\n```java\npublic static final void main() {\n    String var0 = \"print1\";\n    System.out.println(var0);\n    print2and3();\n    var0 = \"print4\";\n    System.out.println(var0);\n    int $i$f$print5 = false;\n    String var1 = \"print5\";\n    System.out.println(var1);\n}\n\npublic static void main(String[] var0) {\n    main();\n}\n\npublic static final void print2and3() {\n    String var0 = \"print2\";\n    System.out.println(var0);\n    var0 = \"print3\";\n    System.out.println(var0);\n}\n\npublic static final void print5() {\n    int $i$f$print5 = 0;\n    String var1 = \"print5\";\n    System.out.println(var1);\n}\n```\n\n```\nprint1\nprint2\nprint3\nprint4\nprint5\n```\n\nkotlin 코드에는 2개의 print는 직접 처리하며, 2개의 print는 함수를 호출해서 출력되는 것으로 보인다. 하지만 이를 java 코드로 변환한 결과를 보면 다소 충격적이다. 실제로 `print5` 함수는 선언만 되어 있을뿐 호출하지 않는다. 내가 만든 함수가 호출되지 않다니! 하지만 해당 함수에 있는 모든 코드가 main문 안에 그대로 들어가 있는 모습이 보인다. 이것이 `inline` 키워드의 역할이다. 그렇다면 이렇게 본래 함수와 호출부에 들어간 코드까지, 코드량을 2배로 만들게 하는 `inline` 키워드가 왜 필요할까?\n\n### inline 고차함수\n\n위 예제의 `print5` 함수의 파라미터만 lambda 고차함수로 바꿔보자.\n\n`Kotlin`\n```kotlin\nfun main(args: ArrayList<String>) {\n    println(\"print1\")\n    print2and3()\n    println(\"print4\")\n    print5 { \"print5\" }\n}\n\nfun print2and3() {\n    println(\"print2\")\n    println(\"print3\")\n}\n\nfun print5(lambda: () -> String) {\n    println(lambda.invoke())\n}\n```\n\n`Java`\n```java\npublic static final void main(@NotNull ArrayList args) {\n    Intrinsics.checkNotNullParameter(args, \"args\");\n    String var1 = \"print1\";\n    System.out.println(var1);\n    print2and3();\n    var1 = \"print4\";\n    System.out.println(var1);\n    print5((Function0)null.INSTANCE);\n}\n\npublic static final void print2and3() {\n    String var0 = \"print2\";\n    System.out.println(var0);\n    var0 = \"print3\";\n    System.out.println(var0);\n}\n\npublic static final void print5(@NotNull Function0 lambda) {\n    Intrinsics.checkNotNullParameter(lambda, \"lambda\");\n    Object var1 = lambda.invoke();\n    System.out.println(var1);\n}\n```\n\njava의 main 함수에서 `print5` 함수를 호출하는 부분을 보면 `(Function0)null.INSTANCE` 부분이 있다. 새로운 Function 익명 클래스 객체를 생성하는 것이다. 즉, 불필요한 객체생성 및 메모리 낭비를 초래할 수 있다는 것이다. `print5` 함수에 inline 키워드만 붙인 java 코드는 아래와 같다.\n\n`Kotlin`\n```kotlin\ninline fun print5(lambda: () -> String) {\n    println(lambda.invoke())\n}\n```\n\n`Java`\n```java\npublic static final void main(@NotNull ArrayList args) {\n    Intrinsics.checkNotNullParameter(args, \"args\");\n    String var1 = \"print1\";\n    System.out.println(var1);\n    print2and3();\n    var1 = \"print4\";\n    System.out.println(var1);\n    int $i$f$print5 = false;\n    int var2 = false;\n    String var4 = \"print5\";\n    System.out.println(var4);\n}\n\npublic static final void print2and3() {\n    String var0 = \"print2\";\n    System.out.println(var0);\n    var0 = \"print3\";\n    System.out.println(var0);\n}\n\npublic static final void print5(@NotNull Function0 lambda) {\n    int $i$f$print5 = 0;\n    Intrinsics.checkNotNullParameter(lambda, \"lambda\");\n    Object var2 = lambda.invoke();\n    System.out.println(var2);\n}\n```\n\n별도의 익명클래스 생성 없이 `print5` 함수 내 로직들이 main안으로 inline 되어있는 모습이다. 이로써 경우 inline 키워드가 주는 장점을 확인 할 수 있었다.\n\n## noinline\n`noinline` 키워드는 `inline` 키워드가 붙어 있는 객체 또는 함수 내에 파라미터 레벨에서 특정 파라미터에 `inline`을 적용하지 않고 싶을때 사용한다. 고차함수를 파라미터로 2개 받는 `print5and6` 함수를 만들었고, 이때 첫번째 파라미터에는 `noinline` 키워드를 붙이고 java 코드로 변경해보았다.\n\n`Kotlin`\n```kotlin\nfun main(args: Array<String>) {\n    println(\"print1\")\n    print2and3()\n    println(\"print4\")\n    print5and6({ \"print5\" }, { \"print6\" })\n}\n\nfun print2and3() {\n    println(\"print2\")\n    println(\"print3\")\n}\n\ninline fun print5and6(noinline lambda: () -> String, lambda2: () -> String) {\n    println(lambda.invoke())\n    println(lambda2.invoke())\n}\n```\n\n`Java`\n```java\npublic static final void main(@NotNull String[] args) {\n    Intrinsics.checkNotNullParameter(args, \"args\");\n    String var1 = \"print1\";\n    System.out.println(var1);\n    print2and3();\n    var1 = \"print4\";\n    System.out.println(var1);\n    Function0 lambda$iv = (Function0)null.INSTANCE;\n    int $i$f$print5and6 = false;\n    Object var3 = lambda$iv.invoke();\n    System.out.println(var3);\n    int var4 = false;\n    String var6 = \"print6\";\n    System.out.println(var6);\n}\n\npublic static final void print2and3() {\n    String var0 = \"print2\";\n    System.out.println(var0);\n    var0 = \"print3\";\n    System.out.println(var0);\n}\n\npublic static final void print5and6(@NotNull Function0 lambda, @NotNull Function0 lambda2) {\n    int $i$f$print5and6 = 0;\n    Intrinsics.checkNotNullParameter(lambda, \"lambda\");\n    Intrinsics.checkNotNullParameter(lambda2, \"lambda2\");\n    Object var3 = lambda.invoke();\n    System.out.println(var3);\n    var3 = lambda2.invoke();\n    System.out.println(var3);\n}\n```\n\njava 코드의 결과를 보면 `noinline`을 적용한 첫번째 고차함수는 익명클래스를 생성하고 있고, 변수에 별도 키워드 없는 두번째 파라미터는 `inline`이 적용된 모습을 볼수 있다.\n\n## 그래서?\n그래서 모든 함수는 `inline`으로 처리하는게 좋을까? 당연히 정답은 X이다. `inline` 키워드에 대해 정리해보자.\n\n`inline` 키워드는 고차함수를 파라미터로 받게되어, 불필요한 익명 클래스 생성을 막을 수 있도록 처리할 때 사용하면 좋다는 것을 알았다. 사실 이또한 객체 하나를 생성하는 비용보다 해당 고차함수를 파라미터로 받은 함수 자체의 로직이 크다면 의미가 없다. 왜냐면 `inline` 키워드가 붙은 함수의 코드를 옮겨오기 때문에 코드량이 2배가 되어 처리해야할 byte량이 많아진다. \n\n결국 아래와 같은 타겟에 `inline` 키워드를 적용 하는게 가장 효과적이라 할 수 있다.\n> 고차함수를 파라미터로 받는 적은량의 코드를 가진 함수\n\n##\n***\n###\n* <https://amitshekhar.me/blog/inline-function-in-kotlin>"},{"excerpt":"Kotlin의 매력 포인트 Null Safe 필요성에 대해서는 두말하면 잔소리다. null에 대한 지원만으로도 너무 행복하다.  java는 null에 취약하며, 언제 어느순간에 NullPointerException이 발생할지 예측할 수 없다. 그래서 늘 null과의 싸움을 하게된다. 떄로는 비즈니스 로직보다 null 체크 로직이 더 많을때도 있다. 물론 …","fields":{"slug":"/kotlin-vs-java/"},"frontmatter":{"date":"January 16, 2023","title":"그래서 kotlin을 선택한 이유는?","tags":["kotlin","java"],"series":"kotlin"},"rawMarkdownBody":"\n\n## Kotlin의 매력 포인트\n\n### Null Safe\n필요성에 대해서는 두말하면 잔소리다. null에 대한 지원만으로도 너무 행복하다. \n\njava는 null에 취약하며, 언제 어느순간에 NullPointerException이 발생할지 예측할 수 없다. 그래서 늘 null과의 싸움을 하게된다. 떄로는 비즈니스 로직보다 null 체크 로직이 더 많을때도 있다. 물론 java8 이후에는 Optional을 활용하여 null safe하게 개발 할 수 있지만 불필요한 코드량과 가독성 측면에서는 여전히 아쉬운게 많다.\n\nkotlin은 기본적으로 모든 변수가 null을 허용하지 않는다. non-null 변수에 null을 할당하려하면 컴파일 단계에서 실패한다. 필요에 따라 null이 필요할땐 `?` 키워드로 nullable을 표현할 수 있다. 또한 타입 추론을 지원하기 때문에 별도의 타입 정의 없이 nullable 변수를  컴파일 시점에서 체크할 수 있다. 추가적으로 ``` if null else ... ``` 을 한번에 표현할 수 있는 `let` 스코프 함수와 null이 아닐때를 표현하는 `?:` 엘비스 연산자(엘비스 프레슬리 헤어스타일을 닮아서...)를 함께 활용하면 더욱 간결하고 null safe하게 개발이 가능하다.\n\n`Kotlin`\n```kt\nfun nonNullReturnFunction(): Int {\n    val num = 1\n    val numOfNullable = nullReturnFunction()\n\n    return numOfNullable?.let { it + num } ?: 0\n}\n\nfun nullReturnFunction(): Int? {\n    val list = listOf(1, 2, 3, 4)\n    return list.firstOrNull { it < 1 }\n}\n```\n\n### Extention\n공통적으로 사용되는 범용성 코드를 잘 만들었을때 뽕맛은 개발자라면 공감할 듯하다.\n\nkotlin에서는 extention 확장함수를 지원한다. 어떤 클래스에 함수를 추가하는 기능이며, extention을 붙여놓은 객체에서 내가 만든 메소드를 사용할 수 있기에 마치 라이브러리를 만든 느낌을 받을 수 있다. json를 다루거나, 자주쓰이는 String 기능을 만들거나 등 불필요한 코드 또는 공통의 기능을 만들때 사용하면 좋다. 좋은 기능이나 자유도가 높기에 무차별하게 사용하면 욕먹기 딱 좋을 수 있다. 특정 클래스에서만 사용하거나 특정 컬렉션에서만 사용하는 등 개인적인 이유로 사용하기에는 일반 비즈니스 함수로 명확하게 개발하는것을 추천한다.\n\n`Java`\n```java\npublic static int firstPlusNum(Collection<Integer> collection, int num) {\n    return collection.stream().findFirst().get() + num;\n}\n\npublic static void main(String[] args) {\n    List<Integer> list = Arrays.asList(1, 2, 3, 4);\n    int result = firstPlusNum(list, 100);\n    System.out.println(result); // 101\n}\n```\n\n아래 kotlin 코드를 java 코드로 변환하면 위와 같다. extention은 결국 static 메소드를 생성한다. static 메소드는 GC의 대상이 되지 못하고 어플리케이션이 기동되는 동안에는 메모리에 남아있다. 결국 무분별하게 extention을 사용할 경우 결국 메모리 낭비를 초래할 것이다. 역시 뭐든 적절하게 필요에 따라 사용하는 것이 건강에 좋다.\n\n`Kotlin`\n```kotlin\nfun List<Int>.firstPlusNum(num: Int): Int {\n    return this.first() + num\n}\n\nfun main() {\n    val list = listOf(1, 2, 3, 4)\n    val result = list.firstPlusNum(100)\n    println(result) // 101\n}\n```\n\nkotlin에서는 특정 Object 하위의 모든 클래스에는 extention이 적용가능하다. 예시로는 Int타입 List의 첫번째 element에 파라미터로 받은 num값을 더해서 반환하도록 작성했으며, 마치 Collection에서 지원하는 메소드인것 처럼 보여지고 있다. 코드를 읽는 입장에서 심신이 편-안하다. 물론 실무에서 특정 컬렉션 구현체에 제너럴하지 못한 타입으로 extention을 만들어 사용하는 일은 드물다. 예제 코드 정도로만 생각했으면 좋겠다.\n\n\n### Checked Exception\n왜지? 라고 의문을 들 수 있는 kotlin의 특징이 있다. checked exception을 지원하지 않는 것이다. 하지만 이유가 납득된다면 이를 kotlin을 선택한 이유로 꼽을 수 있다. \n\n`Java`\n```java\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    throw new RuntimeException(e);\n}\n```\n\n`Kotlin`\n```kotlin\nThread.sleep(1000)\n```\n\nkotlin에서는 Thread에 대한 처리에 대해 묻지도 따지지도 않고 실행 가능하다.\n\n\njava에서는 `Thread.sleep(1000);` 까지만 입력하면 sleep에 redline과 함께 컴파일 에러가 발생한다. java는 Thread를 핸들링하거나 Databse, File, Stream 등 IO에 관련된 영역이나 그외 다방면으로 checked exception을 컴파일 단계에서 처리하도록 강제화한다. 하지만 코틀린은 이를 과감하게 포기했다. 이유는 아래와 같다.\n* checked exception은 비즈니스 로직을 매우 지저분하게 만든다.\n* exception을 강제화 해도 대부분의 개발자는 유의미한 exeption 핸들링을 하지않는다.\n\n어찌보면 발생할 수 있는 exception 위험에 열려있는것 같아 보인다. 무의미하게 throw 처리를 해놓을바엔 필요에따라 적절한 exception 처리를 유도한 것이다. 불필요한 checked exeption을 제거함으로써 얻은 가독성 효과는 확실하다. 다만 java를 사용해보지 않고 kotlin로 입문한 개발자는 어떠한 구문에서 checked exception이 발생될 수 있는지 조차 모를 수 있겠다. 같이 협업하면 조금 난감할지도...\n\n### Coroutines\n비동기 처리가 제일 쉬웠어요. (위험할 소리..😇)\n\ncorutine은 비동기 처리를 굉장히 쉽게 처리 할 수 있도록 지원하는 kotlin 라이브러리다. java에서는 Thread, Callable, Runnable, CompletableFuture 등 다양하게 비동기 개발 방법이 있지만, 예시에서는 CompletableFuture과 비교한다. 비동기 처리시 함께 고민해야할 자원 관리, 동시성 제어, 트랜잭션 처리 등의 내용은 다루지 않는다. just corutine의 편리함만 다룬다.\n\n\n`Java`\n```java\nclass Pizza {\n    final String name;\n    final int minute;\n\n    public Pizza(String name, int minute) {\n        this.name = name;\n        this.minute = minute;\n    }\n\n    public Pizza makePizza() {\n        try {\n            Thread.sleep(this.minute); // make pizza time\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(this.name + \"를 \" + this.minute + \"분만에 완성했습니다.\");\n\n        return this;\n    }\n}\n\npublic class AsyncTest {\n    public static void makePizzaAsync(List<Pizza> pizzas) {\n        List<CompletableFuture<Pizza>> futures = pizzas.stream()\n                .map(pizza -> CompletableFuture.supplyAsync(() -> pizza.makePizza()))\n                .collect(Collectors.toList());\n\n        futures.stream()\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        final List<Pizza> pizzas = Arrays.asList(\n                new Pizza(\"페퍼로니 피자\", 10),\n                new Pizza(\"불고기 피자\", 40),\n                new Pizza(\"하와이언 피자\", 30),\n                new Pizza(\"콰트로치즈 피자\", 20)\n        );\n\n        makePizzaAsync(pizzas);\n    }\n}\n```\n\n\n`Kotlin`\n```kotlin\nfun main() {\n    val pizzas = listOf(\n        Pizza(\"페퍼로니 피자\", 10),\n        Pizza(\"불고기 피자\", 40),\n        Pizza(\"하와이언 피자\", 30),\n        Pizza(\"콰트로치즈 피자\", 20)\n    )\n\n    makePizzaAsync(pizzas)\n}\n\nfun makePizzaAsync(pizzas: List<Pizza>) {\n    runBlocking(Dispatchers.IO) {\n        val defer = pizzas.map {async { it.makePizza() }}\n        defer.awaitAll()\n    }\n}\n\ndata class Pizza(\n    val name: String,\n    val minute: Int\n) {\n    fun makePizza(): Pizza {\n        Thread.sleep(this.minute.toLong())\n        println(this.name + \"를 \" + this.minute + \"분만에 완성했습니다.\");\n        return this\n    }\n}\n```\n\n```\n페퍼로니 피자를 10분만에 완성했습니다.\n콰트로치즈 피자를 20분만에 완성했습니다.\n하와이언 피자를 30분만에 완성했습니다.\n불고기 피자를 40분만에 완성했습니다.\n```\n\n두 언어 모두 결과는 위와같이 로직상 Thread sleep time 순으로 동일하게 프린트된다. main 메소드나 Pizza 객체부를 제외하고 `makePizzaAsync` 메소드를 보면 비동기 처리를 얼마나 간편하게 처리할 수 있는지 알 수 있다.\n\n### Smart Casts\n\n이젠 스마트폰 없이 안되는 세상, 캐스팅도 스마트 캐스팅 시대. 코드의 `ability` 메소드를 보면 바로 직감할 것이다.\n\n`Java`\n```java\ninterface Animal { String getName(); }\n\nclass Dog implements Animal {\n    private final String name;\n\n    Dog(String name) {this.name = name;}\n\n    @Override\n    public String getName() {return this.name;}\n    public String running() {return \"달려요.\";}\n}\n\nclass Bird implements Animal {\n    private final String name;\n\n    Bird(String name) {this.name = name;}\n\n    @Override\n    public String getName() {return this.name;}\n    public String flying() {return \"날아요.\";}\n}\n\npublic class SmartCastTest {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"개\");\n        Bird bird = new Bird(\"새\");\n\n        List<Animal> animals = Arrays.asList(dog, bird);\n        animals.forEach(animal -> {\n            System.out.println(animal.getName() + \"는 \" + ability(animal));\n        });\n    }\n\n    public static String ability(Animal animal) {\n        if (animal instanceof Dog) {\n            Dog dog = (Dog)animal;\n            return dog.running();\n        }\n\n        if (animal instanceof Bird) {\n            Bird dog = (Bird)animal;\n            return dog.flying();\n        }\n\n        throw new RuntimeException(\"동물이 아닙니다.\");\n    }\n}\n```\n\n`Kotlin`\n```kotlin\ninterface Animal { val name: String }\nclass Dog(override val name: String) : Animal { fun running(): String = \"달려요.\" }\nclass Bird(override val name: String) : Animal { fun flying(): String = \"날아요.\" }\n\nfun ability(animal: Animal): String {\n    return when (animal) {\n        is Dog -> animal.running()\n        is Bird -> animal.flying()\n        else -> throw RuntimeException(\"동물을 입력하세요.\")\n    }\n}\n\nfun main() {\n    val dog = Dog(\"개\")\n    val bird = Bird(\"새\")\n\n    val animals = listOf(dog, bird)\n    animals.forEach {\n        println(\"${it.name}는 ${ability(it)}\")\n    }\n}\n```\n\njava는 `instanceof` 이후에도 직접 Animal의 구현체로 down casting 해줘야한다. 하지만 kotlin은 `is` 키워드와 함께 캐스팅된 결과를 받고, 이를 바로 사용할 수 있다. 타입 체크와 변환까지 한번에 지원되는 기능이며 `is` 라는 키워드 자체가 가독성 측면에서도 너무 직관적이고 명확하다. 코드길이 차이는 두말할 것 없다.\n\n### First Class\n\n함수형 프로그래밍을 공부하거나 한번쯤 사용해봤다면 `일급객체` `일급함수` 라는 단어를 봤을 것이다. 아니라면 지금부터 알면된다.\n일급시민(First-class citizen)이 될 수 있는 객체를 일급객체(First-class object), 함수를 일급함수(First-class funcation)으로 지칭할 수 있다.\n일급시민이란 아래 요소를 모두 만족하는 대상을 뜻한다. 아래에는 함수를 예제로 작성한다.\n\n1. 변수에 할당할 수 있다.\n2. 객체의 인자로 넘길 수 있다.\n3. 객체의 반환값으로 반환할 수 있다.\n\n`Kotlin`\n```kotlin\nfun main() {\n    // 1. 변수에 할당할 수 있다.\n    val sum = { x: Int, y: Int -> x + y }\n    println(sum(1, 2))\n\n    val sum2 = sumFun1(sum)\n    println(sum2)\n\n    val sum3 = sumFun2(sum2)\n    println(sum3.invoke())\n}\n\n// 2. 객체의 인자로 넘길 수 있다.\nfun sumFun1(firstClass: (x: Int, y: Int) -> Int): Int {\n    return firstClass.invoke(3, 4)\n}\n\n// 3. 객체의 반환값으로 반환할 수 있다.\nfun sumFun2(sum: Int): () -> Int {\n    return { sum + 5 }\n}\n```\n\n그렇다면 java는 어떨까? kotlin에서는 기본적으로 지원하는 lambda가 java에서는 java8부터 지원하며, 이를 이용하면 비슷한 느낌으로는 만들 수 있다.\n\n`Java`\n```java\n@FunctionalInterface\ninterface Lambda {\n    int sum(int a, int b);\n}\n\n@FunctionalInterface\ninterface Lambda2 {\n    int justReturn();\n}\n\npublic class FirstClassJava {\n    public static void main(String[] args) {\n\n        Lambda sum1 = (int a, int b) -> a + b;\n        System.out.println(sum1.sum(1, 2));\n\n        int sum2 = sumFun1(sum1);\n        System.out.println(sum2);\n\n        Lambda2 sum3 = sumFun2(sum2);\n        System.out.println(sum3.justReturn());\n    }\n\n    public static int sumFun1(Lambda lambdaSum) {\n        return lambdaSum.sum(3, 4);\n    }\n\n    public static Lambda2 sumFun2(int sum) {\n        Lambda2 justReturn = () -> sum + 5;\n        return justReturn;\n    }\n}\n```\n\n```\n3\n7\n12\n```\n\n두 언어 모두 같은 결과를 얻을 수 있다. 하지만 java의 경우 일급시민의 조건을 만족하지 않는다. 하나하나 짚어보자면, `sum1`은 마치 변수에 함수를 할당한 것 처럼 보이지만 이는 java에서 lambda를 할당하기 위해서 interface를 만들도록 강제화 되어있다. `sumFun1`의 파라미터로 `Lambda` 객체를 넘겨야하며, 함수(lambda)를 넘길 순 없다. `sumFun2`의 반환형으로 함수(lambda)를 반환할 수 없으며 `Lambda2`를 반환 해야한다. 즉, java에서 lambda를 이용하여 kotlin과 구조적으로 비슷한 형태로 개발할 수 있지만 java는 일급시민(함수, 객체)이 될 수 없는 언어라는 점이다.\n\n금융회사 재직당시 특정 프로젝트에서 java 1.6을 사용하는 곳을 보았지만, 이런 경우는 어쩔 수 없이 사용할 수 없을것이다. 하지만 java8 이상을 사용하면서도 lambda, stream 등의 함수형 프로그래밍 지식을 습득하지 못하여 거부감을 느껴하는 케이스도 보았다. kotlin에서는 언어 레벨에서 간결하고 쉽게 사용할 수 있도록 지원되어 가장 큰 장점이라 생각되었다.\n\n### Immutable\n\n언어 레벨에서 지원하는 불변성의 효과는 실로 기가막히다.\n\n`Java`\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\npublic class FirstClassJava {\n    public static void main(String[] args) {\n        Person person = new Person(\"wookey\", 30);\n        System.out.println(changeName1(person).getName());\n    }\n\n    public static Person changeName1(Person person) {\n        person.setName(person.getName() + \"변경1\");\n        return changeName2(person);\n    }\n\n    public static Person changeName2(Person person) {\n        person.setName(person.getName() + \"변경2\");\n        return changeName3(person);\n    }\n\n    public static Person changeName3(Person person) {\n        person.setName(person.getName() + \"변경3\");\n        return person;\n    }\n}\n```\n\n실무에서 이렇게 극단적인 코드는 없을것 같다고 생각될 것이다. 하지만 실제로 실무 코드에도 수개의 메소드의 파라미터에 레퍼런스를 받고 이를 변경하고 최종적으로 결과를 받는 형태의 코드는 상당히 많다. 그것도 예제 코드처럼 단순한 변경이 아닌, 수많은 비즈니스 로직과 얽히고 엮여 레퍼런스의 값을 계속 변경, 조작하는 코드들 말이다.\n\n`Kotlin`\n```kotlin\ndata class Person(val name: String, val age: Int)\n\nfun main() {\n    val person = Person(\"wookey\", 30)\n    println(changeName1(person).name)\n}\n\nfun changeName1(person: Person): Person {\n    person.name = person.name + \"변경1\"\n    return changeName2(person)\n}\n\nfun changeName2(person: Person): Person {\n    person.name = person.name + \"변경2\"\n    return changeName3(person)\n}\n\nfun changeName3(person: Person): Person {\n    person.name = person.name + \"변경3\"\n    return person\n}\n```\n\n예제 java코드를 kotlin으로 옮기면 위와 같다. 정확히 말하자면 느낌만 옮긴것이다. 위 kotlin 코드는 컴파일되지 않는다. 언어레벨에서 main문에 선언한 `Person` 객체에 선언한 `name` 필드를 `val` 이라는 키워드로 변경불가능한 immutable(final) 변수로 만들었기 때문이다. 어찌보면 `name` 필드의 키워드를 `val`에서 `var`로 변경만 하면 컴파일될 뿐 아니라 java 코드와 동일한 결과를 가져 올 수 있다. 하지만 여기서 얻을 수 있는 인사이트가 있다. 왜 kotlin은 기본적으로 언어 레벨에서 final 키워드를 채택한 것일까? 만약 kotlin 코드에서 `var` 키워드로 바꾸지않고 동일한 결과를 가져 오려면 각 메소드마다 아래와 같이 작성해야할 것이다.\n\n```kotlin\nfun changeName1(person: Person): Person {\n    val newPerson = Person(person.name + \"변경1\", person.age)\n    return newPerson\n}\n```\n\n이는 사실상 결과만 같지 다른 코드이다. 레퍼런스의 값을 바꾸는게 아닌, 새로운 객체를 계속 만들어내는 방법이기 때문이다. 결과적으로 레퍼런스를 조작하는 코드는 결코 좋지못한 코드를 양산해낼 가능성이 높다. 즉, kotlin은 레퍼런스의 변경을 최대한 막고 하나의 메소드는 자신의 역할만 충실히 하도록 개발할 수 있도록 언어레벨에서 지원하는 것이다. 이는 결국 OOP원칙 중 SRP(Single Responsibility Principle)에 굉장히 충실할 수 있다고 생각한다. 결과론적으로 immutable의 지원은 유지보수 좋은 코드, 생산성 있는 코드를 만들 수 있다고 생각한다.\n\n\n## Kotlin은 단점이 없는가?\n\n결론부터 말하면 아니다. 모든 언어에는 특징이 있으며, 자신의 입맛도 중요하지만 시장의 수요도 중요하다. 기술적으로만 보았을때 kotlin은 java 기반으로 만들어졌고 동일하게 JVM 아래에서 돌아간다. java의 불편한 단점들을 보완하기 위해 태어난 언어이므로 기술적인 부분보다는 그 외적 이유로 단점을 꼽아 볼 수 있다.\n\n* 새로운 언어이므로 개발자 커뮤니티가 작을 수 있다. \n* 대한민국은 java 공화국이라는 별명이 있을정도로 java에 대한 애착심이 높다. 그렇다면 취업의 입장에서 수요 차이는 분명할 수 있다.\n* kotlin은 java와 100% 호환되는 언어라고 제작사에서 언급한다. `SomeClass::class.java` 와 같은 리플렉션 문법은 `KClass` 라는 kotlin 클래스로 랩핑된다. 이와 같은 사용은 모호한 java 문법과의 호환이 있어 보인다.\n* 시간이 해결해줄 것 같지만, 아직까지 완벽 지원되지 않는 라이브러리나 개발툴(IDE)가 있다. 특히 kotlin은 intellij IDE 개발사인 jetbranin에서 만든 언어이므로 다양한 IDE가 나오기 전까진 특정 IDE에 특화된 언어라는 제약이 있다.\n* 함수형 언어라는 패러다임 자체를 긍정적으로 이해하지 못하는 집단들에게 선택받지 못할 수 있다.\n* 개발 공부 자체를 처음 배우는 입문자에게 추천하기 어려울 것 같다. 아무래도 kotlin의 기본 base는 JVM java이며, 특징을 모른채 개발하게 된다면 기본적이고 중요한 지식을 많이 놓칠 수 있다고 생각된다.\n\n\n## 그래서?\n그래서 기존 java의 사용자라면 충분히 메리트를 느끼고 kotlin에게 매력을 느낄 수 있을 것이다. 나도 학부생 시절 포함하여 개발자 커리어 전부를 java로 개발했다. 하지만 익숙하면서도 많은 변화를 가져다준 kotlin의 릴리즈를 지켜보며 과감하게 주 언어를 변경할 수 있었다. 포스트에 언급하지 않은 kotlin의 장점과 단점은 더 많이 있겠지만 kotlin을 주 개발 언어로 선택한 이유를 요약하면 아래와 같이 정리 할 수 있을것 같다.\n\n* Concise (간결성)\n* Safe (안정성)\n* Interoperable (상호운용가능성)\n\n결국 아래와 같은 타겟에게 kotlin을 추천한다.\n> java 실무 경험이 있으며, 간결하고 명료한 jvm 기반의 코드를 원하는 개발자\n\n\n##\n***\n###\n* <https://www.makeuseof.com/kotlin-vs-java/#code-volume-amp-speed-of-coding>\n* <https://kotlinlang.org/docs/comparison-to-java.html#what-kotlin-has-that-java-does-not>"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}